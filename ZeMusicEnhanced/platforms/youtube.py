#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
๐ต ZeMusic Bot v3.0 - Enhanced YouTube Platform
ุชุงุฑูุฎ ุงูุฅูุดุงุก: 2025-01-28

ููุตุฉ YouTube ุงููุญุณูุฉ ูุน ุฏุนู yt-dlp
"""

import asyncio
import logging
import re
from typing import Dict, List, Optional, Any
from urllib.parse import urlparse, parse_qs

try:
    import yt_dlp
    YT_DLP_AVAILABLE = True
except ImportError:
    YT_DLP_AVAILABLE = False

from .platform_manager import BasePlatform
from ..config import config

logger = logging.getLogger(__name__)

class YouTubePlatform(BasePlatform):
    """ููุตุฉ YouTube"""
    
    def __init__(self):
        super().__init__("YouTube")
        self.ydl = None
        self.search_limit = 10
    
    async def initialize(self) -> bool:
        """ุชููุฆุฉ ููุตุฉ YouTube"""
        try:
            if not YT_DLP_AVAILABLE:
                logger.error("โ yt-dlp ุบูุฑ ูุชุงุญ - ูู ุชุนูู ููุตุฉ YouTube")
                return False
            
            # ุฅุนุฏุงุฏุงุช yt-dlp
            ydl_opts = {
                'format': 'bestaudio[ext=m4a]/bestaudio[ext=mp3]/bestaudio',
                'noplaylist': True,
                'extractaudio': True,
                'audioformat': 'mp3',
                'outtmpl': f"{config.music.temp_path}/%(title)s.%(ext)s",
                'quiet': True,
                'no_warnings': True,
                'ignoreerrors': True,
                'socket_timeout': 30,
                'retries': 3
            }
            
            # ุฅุถุงูุฉ cookie file ุฅุฐุง ูุงู ูุชุงุญุงู
            if config.music.youtube_cookies_path:
                ydl_opts['cookiefile'] = config.music.youtube_cookies_path
            
            self.ydl = yt_dlp.YoutubeDL(ydl_opts)
            self.is_available = True
            
            logger.info("โ ุชู ุชููุฆุฉ ููุตุฉ YouTube ุจูุฌุงุญ")
            return True
            
        except Exception as e:
            logger.error(f"โ ูุดู ูู ุชููุฆุฉ ููุตุฉ YouTube: {e}")
            return False
    
    async def search(self, query: str, limit: int = 10) -> List[Dict[str, Any]]:
        """ุงูุจุญุซ ูู YouTube"""
        try:
            if not self.is_available:
                return []
            
            # ุชูุธูู ุงุณุชุนูุงู ุงูุจุญุซ
            clean_query = self._clean_search_query(query)
            
            # ุชุดุบูู ุงูุจุญุซ ูู thread ูููุตู
            loop = asyncio.get_event_loop()
            results = await loop.run_in_executor(
                None, 
                self._search_youtube, 
                clean_query, 
                limit
            )
            
            return results
            
        except Exception as e:
            logger.error(f"โ ูุดู ุงูุจุญุซ ูู YouTube: {e}")
            return []
    
    def _search_youtube(self, query: str, limit: int) -> List[Dict[str, Any]]:
        """ุงูุจุญุซ ุงููุนูู ูู YouTube"""
        try:
            search_query = f"ytsearch{limit}:{query}"
            
            # ุงุณุชุฎุฑุงุฌ ูุนูููุงุช ุงูุจุญุซ
            with yt_dlp.YoutubeDL({'quiet': True, 'no_warnings': True}) as ydl:
                search_results = ydl.extract_info(
                    search_query,
                    download=False,
                    process=False
                )
            
            results = []
            
            if search_results and 'entries' in search_results:
                for entry in search_results['entries']:
                    if entry:
                        result = self._format_youtube_result(entry)
                        if result:
                            results.append(result)
            
            return results
            
        except Exception as e:
            logger.error(f"โ ุฎุทุฃ ูู ุงูุจุญุซ ุงููุนูู ูู YouTube: {e}")
            return []
    
    def _format_youtube_result(self, entry: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """ุชูุณูู ูุชูุฌุฉ ุงูุจุญุซ ูู YouTube"""
        try:
            # ุงูุชุญูู ูู ุงูุจูุงูุงุช ุงูุฃุณุงุณูุฉ
            if not entry.get('id') or not entry.get('title'):
                return None
            
            # ููุชุฑุฉ ุงููุญุชูู ุบูุฑ ุงููุฑุบูุจ
            title = entry.get('title', '').lower()
            if any(keyword in title for keyword in ['live', 'stream', 'news', 'talk']):
                # ุชุฎุทู ุงูุจุซูุซ ุงููุจุงุดุฑุฉ ูุงูุฃุฎุจุงุฑ
                if entry.get('duration', 0) > 3600:  # ุฃูุซุฑ ูู ุณุงุนุฉ
                    return None
            
            # ุงุณุชุฎุฑุงุฌ ูุนูููุงุช ุงูููุทุน
            result = {
                'id': entry['id'],
                'title': entry.get('title', 'ุนููุงู ุบูุฑ ูุนุฑูู'),
                'url': f"https://www.youtube.com/watch?v={entry['id']}",
                'duration': entry.get('duration', 0),
                'thumbnail': self._get_best_thumbnail(entry.get('thumbnails', [])),
                'uploader': entry.get('uploader', 'ููุงุฉ ุบูุฑ ูุนุฑููุฉ'),
                'view_count': entry.get('view_count', 0),
                'upload_date': entry.get('upload_date', ''),
                'description': entry.get('description', '')[:200] + '...' if entry.get('description') else '',
                'quality': self._determine_quality(entry),
                'platform': 'youtube',
                'platform_display': 'YouTube'
            }
            
            # ุฅุถุงูุฉ ูุนูููุงุช ุฅุถุงููุฉ
            result['artist'] = self._extract_artist(result['title'], result['uploader'])
            result['views'] = result['view_count']
            
            return result
            
        except Exception as e:
            logger.error(f"โ ุฎุทุฃ ูู ุชูุณูู ูุชูุฌุฉ YouTube: {e}")
            return None
    
    def _get_best_thumbnail(self, thumbnails: List[Dict[str, Any]]) -> str:
        """ุงูุญุตูู ุนูู ุฃูุถู ุตูุฑุฉ ูุตุบุฑุฉ"""
        try:
            if not thumbnails:
                return ""
            
            # ุชุฑุชูุจ ุงูุตูุฑ ุญุณุจ ุงูุฌูุฏุฉ
            sorted_thumbs = sorted(
                thumbnails, 
                key=lambda x: x.get('width', 0) * x.get('height', 0), 
                reverse=True
            )
            
            return sorted_thumbs[0].get('url', '') if sorted_thumbs else ""
            
        except Exception:
            return ""
    
    def _determine_quality(self, entry: Dict[str, Any]) -> str:
        """ุชุญุฏูุฏ ุฌูุฏุฉ ุงูููุทุน"""
        try:
            # ุจูุงุกู ุนูู ูุฏุฉ ุงูููุทุน ูุนุฏุฏ ุงููุดุงูุฏุงุช
            duration = entry.get('duration', 0)
            views = entry.get('view_count', 0)
            
            # ููุงุทุน ูุตูุฑุฉ ุฌุฏุงู ุฃู ุทูููุฉ ุฌุฏุงู = ุฌูุฏุฉ ููุฎูุถุฉ
            if duration < 30 or duration > 1800:  # ุฃูู ูู 30 ุซุงููุฉ ุฃู ุฃูุซุฑ ูู 30 ุฏูููุฉ
                return 'low'
            
            # ููุงุทุน ุจูุดุงูุฏุงุช ุนุงููุฉ = ุฌูุฏุฉ ุนุงููุฉ
            if views > 1000000:
                return 'high'
            elif views > 100000:
                return 'medium'
            else:
                return 'low'
                
        except Exception:
            return 'medium'
    
    def _extract_artist(self, title: str, uploader: str) -> str:
        """ุงุณุชุฎุฑุงุฌ ุงุณู ุงูููุงู"""
        try:
            # ุฃููุงุท ุดุงุฆุนุฉ ูุงุณุชุฎุฑุงุฌ ุงุณู ุงูููุงู
            patterns = [
                r'^([^-]+)\s*-',  # "Artist - Song"
                r'^([^โ]+)\s*โ',  # "Artist โ Song" (em dash)
                r'([^|]+)\s*\|',  # "Artist | Song"
                r'([^โข]+)\s*โข',   # "Artist โข Song"
            ]
            
            for pattern in patterns:
                match = re.search(pattern, title.strip())
                if match:
                    artist = match.group(1).strip()
                    if len(artist) > 2 and len(artist) < 50:
                        return artist
            
            # ุฅุฐุง ูู ูุฌุฏ ููุทุ ูุณุชุฎุฏู ุงุณู ุงูููุงุฉ
            return uploader
            
        except Exception:
            return uploader
    
    def _clean_search_query(self, query: str) -> str:
        """ุชูุธูู ุงุณุชุนูุงู ุงูุจุญุซ"""
        try:
            # ุฅุฒุงูุฉ ุงููููุงุช ุบูุฑ ุงููุฑุบูุจุฉ
            unwanted_words = ['official', 'video', 'audio', 'lyrics', 'hd', '4k']
            
            # ุชูุธูู ุฃุณุงุณู
            clean_query = query.strip()
            
            # ุฅุฒุงูุฉ ุนูุงูุงุช ุงูุชุฑููู ุงูุฒุงุฆุฏุฉ
            clean_query = re.sub(r'[^\w\s\u0600-\u06FF-]', ' ', clean_query)
            
            # ุฅุฒุงูุฉ ุงููุณุงูุงุช ุงูุฒุงุฆุฏุฉ
            clean_query = re.sub(r'\s+', ' ', clean_query).strip()
            
            return clean_query
            
        except Exception:
            return query
    
    async def get_stream_url(self, track_id: str) -> Optional[str]:
        """ุงูุญุตูู ุนูู ุฑุงุจุท ุงูุชุดุบูู"""
        try:
            if not self.is_available:
                return None
            
            url = f"https://www.youtube.com/watch?v={track_id}"
            
            # ุงุณุชุฎุฑุงุฌ ูุนูููุงุช ุงูุณุชุฑูู
            loop = asyncio.get_event_loop()
            stream_info = await loop.run_in_executor(
                None,
                self._extract_stream_info,
                url
            )
            
            return stream_info.get('url') if stream_info else None
            
        except Exception as e:
            logger.error(f"โ ูุดู ูู ุงูุญุตูู ุนูู ุฑุงุจุท ุงูุชุดุบูู: {e}")
            return None
    
    def _extract_stream_info(self, url: str) -> Optional[Dict[str, Any]]:
        """ุงุณุชุฎุฑุงุฌ ูุนูููุงุช ุงูุณุชุฑูู"""
        try:
            with yt_dlp.YoutubeDL({
                'format': 'bestaudio[ext=m4a]/bestaudio[ext=mp3]/bestaudio',
                'quiet': True,
                'no_warnings': True
            }) as ydl:
                info = ydl.extract_info(url, download=False)
                
                if info and 'url' in info:
                    return {
                        'url': info['url'],
                        'title': info.get('title', ''),
                        'duration': info.get('duration', 0)
                    }
            
            return None
            
        except Exception as e:
            logger.error(f"โ ุฎุทุฃ ูู ุงุณุชุฎุฑุงุฌ ูุนูููุงุช ุงูุณุชุฑูู: {e}")
            return None
    
    async def get_track_info(self, track_id: str) -> Optional[Dict[str, Any]]:
        """ุงูุญุตูู ุนูู ูุนูููุงุช ุงูููุทุน"""
        try:
            if not self.is_available:
                return None
            
            url = f"https://www.youtube.com/watch?v={track_id}"
            
            # ุงุณุชุฎุฑุงุฌ ูุนูููุงุช ุงูููุทุน
            loop = asyncio.get_event_loop()
            info = await loop.run_in_executor(
                None,
                self._extract_track_info,
                url
            )
            
            return info
            
        except Exception as e:
            logger.error(f"โ ูุดู ูู ุงูุญุตูู ุนูู ูุนูููุงุช ุงูููุทุน: {e}")
            return None
    
    def _extract_track_info(self, url: str) -> Optional[Dict[str, Any]]:
        """ุงุณุชุฎุฑุงุฌ ูุนูููุงุช ุงูููุทุน"""
        try:
            with yt_dlp.YoutubeDL({'quiet': True, 'no_warnings': True}) as ydl:
                info = ydl.extract_info(url, download=False)
                
                if info:
                    return self._format_youtube_result(info)
            
            return None
            
        except Exception as e:
            logger.error(f"โ ุฎุทุฃ ูู ุงุณุชุฎุฑุงุฌ ูุนูููุงุช ุงูููุทุน: {e}")
            return None
    
    async def download_track(self, track_id: str, output_path: str) -> Optional[str]:
        """ุชูุฒูู ุงูููุทุน ุงูุตูุชู"""
        try:
            if not self.is_available:
                return None
            
            url = f"https://www.youtube.com/watch?v={track_id}"
            
            # ุฅุนุฏุงุฏุงุช ุงูุชูุฒูู
            ydl_opts = {
                'format': 'bestaudio[ext=m4a]/bestaudio[ext=mp3]/bestaudio',
                'extractaudio': True,
                'audioformat': 'mp3',
                'outtmpl': f"{output_path}/%(title)s.%(ext)s",
                'quiet': True,
                'no_warnings': True
            }
            
            # ุชูุฒูู ูู thread ูููุตู
            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(
                None,
                self._download_track,
                url,
                ydl_opts
            )
            
            return result
            
        except Exception as e:
            logger.error(f"โ ูุดู ูู ุชูุฒูู ุงูููุทุน: {e}")
            return None
    
    def _download_track(self, url: str, ydl_opts: Dict[str, Any]) -> Optional[str]:
        """ุชูุฒูู ุงูููุทุน ุงููุนูู"""
        try:
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                # ุงุณุชุฎุฑุงุฌ ูุนูููุงุช ุงูููู
                info = ydl.extract_info(url, download=False)
                
                if info:
                    # ุชูุฒูู ุงูููู
                    ydl.download([url])
                    
                    # ุฅุฑุฌุงุน ูุณุงุฑ ุงูููู
                    filename = ydl.prepare_filename(info)
                    return filename.rsplit('.', 1)[0] + '.mp3'
            
            return None
            
        except Exception as e:
            logger.error(f"โ ุฎุทุฃ ูู ุงูุชูุฒูู ุงููุนูู: {e}")
            return None
    
    def is_youtube_url(self, url: str) -> bool:
        """ุงูุชุญูู ูู ุฃู ุงูุฑุงุจุท ูู YouTube"""
        try:
            parsed = urlparse(url)
            return parsed.netloc in ['www.youtube.com', 'youtube.com', 'youtu.be', 'm.youtube.com']
        except Exception:
            return False
    
    def extract_video_id(self, url: str) -> Optional[str]:
        """ุงุณุชุฎุฑุงุฌ ูุนุฑู ุงูููุฏูู ูู ุงูุฑุงุจุท"""
        try:
            parsed = urlparse(url)
            
            if parsed.netloc == 'youtu.be':
                return parsed.path[1:]
            elif 'youtube.com' in parsed.netloc:
                if 'watch' in parsed.path:
                    return parse_qs(parsed.query).get('v', [None])[0]
                elif 'embed' in parsed.path:
                    return parsed.path.split('/')[-1]
            
            return None
            
        except Exception:
            return None